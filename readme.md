# 🚀 CacheSystem - 高性能 C++ 缓存系统

<div align="center">

![C++](https://img.shields.io/badge/C++-17-blue.svg?style=flat&logo=c%2B%2B)

一个高效、现代化的 C++ 缓存系统实现，支持多种缓存淘汰策略和并发优化，header-only

[项目介绍](#项目介绍) • [算法说明](#算法说明) • [性能测试](#性能测试)

</div>

---

## 📖 项目简介

本项目是一个基于 C++17 实现的高性能缓存系统，提供了多种常见的缓存淘汰策略实现。该项目不仅包含基础算法，还针对并发场景进行了优化，适用于需要高效缓存管理的应用场景。

### ✨ 功能特性

- **🎯 多种缓存策略**：实现了 6 种常见的缓存淘汰算法
- **⚡ 高性能**：针对性能进行了优化，支持高吞吐量场景
- **🔒 并发支持**：提供分片缓存实现，提高并发性能
- **🧪 完善的测试**：包含多种测试场景，验证算法效果
- **📊 性能对比**：提供详细的性能测试报告和对比分析
- **🛠️ 易于集成**：清晰的接口设计，header-only，方便集成到其他项目

## 📋 支持的缓存淘汰策略

### 1. LRU（Least Recently Used - 最近最少使用）

- **基础 LRU**：经典的 LRU 算法实现
- **LRU-K**：增强版 LRU，需要访问 K 次才进入缓存，有效避免热数据被大量冷数据淘汰
- **HashLRU**：分片 LRU，通过分片技术提高并发性能

### 2. LFU（Least Frequently Used - 最不经常使用）

- **基础 LFU**：基于访问频率的淘汰策略，加入最大平均频次机制，避免旧热点数据无法清除
- **HashLFU**：分片 LFU，提升多线程环境下的性能表现

### 3. ARC（Adaptive Replacement Cache - 自适应替换缓存）

- **基础 ARC**：自适应缓存替换策略，动态结合 LRU 和 LFU 的优点，根据工作负载自动调整策略比例

## 📚 算法说明

### LRU（Least Recently Used）

**原理**：优先淘汰最久未被访问的数据。使用双向链表和哈希表实现，时间复杂度 O(1)。

**适用场景**：适合访问模式有时间局部性的场景。

**实现特点**：

- 使用双向链表维护访问顺序
- 哈希表提供 O(1) 查找
- 空间复杂度 O(n)

### LRU-K

**原理**：数据需要被访问 K 次后才会进入主缓存，避免偶然访问的数据污染缓存。

**适用场景**：存在大量扫描访问的场景，可以有效过滤冷数据。

**实现特点**：

- 维护历史访问队列
- 只有达到 K 次访问才进入缓存
- 提高缓存的数据质量

### LFU（Least Frequently Used）

**原理**：优先淘汰访问频率最低的数据。适合热点数据相对稳定的场景。

**适用场景**：数据访问频率差异明显，热点数据相对固定。

**实现特点**：

- 维护频率计数
- 支持最大平均频次机制
- 防止旧热点数据常驻

### ARC（Adaptive Replacement Cache）

**原理**：自适应地在 LRU 和 LFU 之间动态调整，根据访问模式自动优化。

**适用场景**：工作负载变化大，需要算法自动适应的场景。

**实现特点**：

- 维护 T1（最近访问一次）和 T2（最近访问多次）两个列表
- 动态调整两个列表的大小
- 对不同访问模式有良好的适应性

---

## 📊 性能测试

本项目包含三种测试场景，全面评估各算法的性能表现：

### 测试环境

- **测试指标**：命中率、执行时间、吞吐量
- **测试场景**：热点数据访问、循环扫描、工作负载变化
- **对比算法**：LRU、LRU-K(k=2)、HashLRU、LFU、HashLFU、ARC

### 测试结果

```bash
🔧 缓存系统性能测试程序

🎯 本程序将对比以下6种缓存淘汰算法的性能表现:

📋 测试指标包括:
  • 命中率 (Hit Rate) - 缓存命中的百分比
  • 执行时间 (Execution Time) - 算法执行耗时
  • 吞吐量 (Throughput) - 每秒处理的操作数

🚀 开始缓存系统综合性能测试 🚀
本次测试将对比 LRU、LRU-K(k=2)、HashLRU、LFU、HashLFU、ARC 六种缓存淘汰策略
测试包含三个场景：热点数据访问、循环扫描、工作负载变化
========================================================================================================================

=== 测试场景1：热点数据访问测试 ===
正在测试 LRU 算法...
{Timer}[LRU 算法] took 285.48 ms
正在测试 LRU-K 算法...
{Timer}[LRU-K 算法] took 430.406 ms
正在测试 HashLRU 算法...
{Timer}[HashLRU 算法] took 311.743 ms
正在测试 LFU 算法...
{Timer}[LFU 算法] took 405.679 ms
正在测试 HashLFU 算法...
{Timer}[HashLFU 算法] took 434.933 ms
正在测试 ARC 算法...
{Timer}[ARC 算法] took 1213.31 ms

=== 热点数据访问测试 性能测试结果 ===
缓存容量: 20
----------------------------------------------------------------------------------------------------
        算法    命中率(%)       命中次数        总操作数        执行时间(ms)    吞吐量(ops/s)
----------------------------------------------------------------------------------------------------
        LRU     93.40           326489          349546          285             1226477
        LRU-K   93.38           327066          350234          430             814498
        HashLRU 93.40           326511          349578          311             1124045
        LFU     66.64           233075          349754          405             863590
        HashLFU 60.40           211153          349612          434             805558
        ARC     96.54           337632          349724          1213            288313
----------------------------------------------------------------------------------------------------

=== 热点数据访问测试 性能对比分析 ===
💡 最佳命中率: ARC (96.54%)
⚡ 最佳吞吐量: LRU (1226477 ops/s)


=== 测试场景2：循环扫描测试 ===
正在测试 LRU 算法...
{Timer}[LRU 算法] took 97 ms
正在测试 LRU-K 算法...
{Timer}[LRU-K 算法] took 136 ms
正在测试 HashLRU 算法...
{Timer}[HashLRU 算法] took 109 ms
正在测试 LFU 算法...
{Timer}[LFU 算法] took 94 ms
正在测试 HashLFU 算法...
{Timer}[HashLFU 算法] took 103 ms
正在测试 ARC 算法...
{Timer}[ARC 算法] took 185 ms

=== 循环扫描测试 性能测试结果 ===
缓存容量: 50
----------------------------------------------------------------------------------------------------
        算法    命中率(%)       命中次数        总操作数        执行时间(ms)    吞吐量(ops/s)
----------------------------------------------------------------------------------------------------
        LRU     95.45           152724          160008          97              1649567
        LRU-K   95.41           152786          160143          135             1186244
        HashLRU 95.57           153131          160231          108             1483620
        LFU     8.90            14230           159804          93              1718323
        HashLFU 9.01            14426           160114          102             1569745
        ARC     97.71           156242          159903          184             869038
----------------------------------------------------------------------------------------------------

=== 循环扫描测试 性能对比分析 ===
💡 最佳命中率: ARC (97.71%)
⚡ 最佳吞吐量: LFU (1718323 ops/s)


=== 测试场景3：工作负载剧烈变化测试 ===
正在测试 LRU 算法...
{Timer}[LRU 算法] took 4 ms
正在测试 LRU-K 算法...
{Timer}[LRU-K 算法] took 7 ms
正在测试 HashLRU 算法...
{Timer}[HashLRU 算法] took 4 ms
正在测试 LFU 算法...
{Timer}[LFU 算法] took 5 ms
正在测试 HashLFU 算法...
{Timer}[HashLFU 算法] took 6 ms
正在测试 ARC 算法...
{Timer}[ARC 算法] took 8 ms

=== 工作负载剧烈变化测试 性能测试结果 ===
缓存容量: 30
----------------------------------------------------------------------------------------------------
        算法    命中率(%)       命中次数        总操作数        执行时间(ms)    吞吐量(ops/s)
----------------------------------------------------------------------------------------------------
        LRU     78.64           5014            6376            3               2125333
        LRU-K   78.00           4973            6376            6               1062667
        HashLRU 78.15           4993            6389            3               2129667
        LFU     39.71           2529            6369            5               1273800
        HashLFU 47.14           3004            6373            6               1062167
        ARC     87.61           5613            6407            8               800875
----------------------------------------------------------------------------------------------------

=== 工作负载剧烈变化测试 性能对比分析 ===
💡 最佳命中率: ARC (87.61%)
⚡ 最佳吞吐量: HashLRU (2129667 ops/s)


====================================================================================================
🎉 缓存系统综合性能测试完成！
总耗时: 3860 毫秒
====================================================================================================

✅ 程序执行完成！
```

### 📈 性能测试总结

#### 场景 1：热点数据访问测试

**最佳算法**：

- **命中率冠军**：ARC (96.54%) - 自适应策略在热点数据场景表现优异
- **吞吐量冠军**：LRU (1,226,477 ops/s) - 简单高效的设计带来最佳性能

**关键发现**：

- LRU 系列算法在热点数据访问场景下表现稳定，命中率达 93%+
- LFU 系列在热点数据集中场景表现不佳（60-66%），因为频率统计需要更长时间积累
- ARC 通过自适应机制获得最高命中率，但吞吐量较低

#### 场景 2：循环扫描测试

**最佳算法**：

- **命中率冠军**：ARC (97.71%) - 对循环访问模式有很好的适应性
- **吞吐量冠军**：LFU (1,718,323 ops/s) - 在该场景下的高效实现

**关键发现**：

- LRU 系列算法在循环扫描场景表现优秀（95%+命中率）
- LFU 系列命中率很低（8-9%），不适合循环扫描场景
- ARC 依然保持最高命中率，展现出良好的适应能力

#### 场景 3：工作负载剧烈变化测试

**最佳算法**：

- **命中率冠军**：ARC (87.61%) - 自适应特性在变化场景中优势明显
- **吞吐量冠军**：HashLRU (2,129,667 ops/s) - 分片设计带来极致性能

**关键发现**：

- ARC 在工作负载变化场景中保持最高命中率
- LRU 系列命中率约 78%，性能稳定
- LFU 系列命中率较低（39-47%），难以快速适应工作负载变化

#### 🏆 综合结论

| 算法        | 优势场景           | 劣势场景             | 推荐指数   |
| ----------- | ------------------ | -------------------- | ---------- |
| **LRU**     | 通用场景，简单高效 | 循环扫描较大数据集   | ⭐⭐⭐⭐   |
| **LRU-K**   | 扫描访问多的场景   | 性能开销较大         | ⭐⭐⭐     |
| **HashLRU** | 高并发场景         | 单线程性能略低       | ⭐⭐⭐⭐⭐ |
| **LFU**     | 热点稳定场景       | 工作负载变化大的场景 | ⭐⭐⭐     |
| **HashLFU** | 高并发+热点稳定    | 工作负载变化大的场景 | ⭐⭐⭐     |
| **ARC**     | 工作负载不确定     | 对性能要求极高的场景 | ⭐⭐⭐⭐⭐ |
